
<html>
<head>
    <title>Main Alignment-free Tools Comparisons</title>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>

    <script>
        var target = null;
        var over = null;
        $(document).ready(function() {
            $(".hint").click(function(event) {
                if( over != null ) {
                    over.children('.hintt').css('visibility','');
                    over = null;
                }
                if( target != null && (target.is(event.target) || target.children().is(event.target)) ) {
                    event.stopPropagation();
                    return;
                }
                if( target != null ) {
                    target.children('.hintt').css('visibility','');
                }
                target = $(event.target);
                target.children('.hintt').css('visibility','visible');
                event.stopPropagation();
            });
            $(document).click(function(event) {
                if( over != null ) {
                    over.children('.hintt').css('visibility','');
                    over = null;
                }
                if( target != null && !target.is(event.target) && !target.children().is(event.target) ) {
                    target.children('.hintt').css('visibility','');
                    target = null;
                }
            });
            $(".hint").mouseover(function(event) {
                if( over != null ) {
                    over.children('.hintt').css('visibility','');
                    over = null;
                }
                if( target != null && !target.is(event.target) && !target.children().is(event.target) ) {
                    over = $(event.target);
                    over.children('.hintt').css('visibility','hidden');
                }
                /*if( target != null && !target.is(event.target) && !target.children().is(event.target) ) {
                    target.children('.hintt').css('visibility','');
                    target = null;
                }*/
            });
        });
    </script>

    <style>

        body {
            font-family:Georgia, serif;
            font-size:12pt;
            margin-left:10px;
            margin-top:10px;
            background-color:#333;
        }

        #main {
            width: 1000px;
            background-color: #FFF;
            margin: auto;
            margin-top:10px;
            margin-bottom:10px;
            padding: 30px;
        }

        h1 {
            font-family:Verdana, sans-serif;
        }

        .hint {
            position: relative;
        }

        .hint .hintt {
            position: absolute;
            visibility: hidden;
            background-color: #ccf;
            width:300px;
            color: black;
            border-radius: 6px;
            border: 2px solid black;
            padding: 5px 10px;
            z-index: 5;
            font-weight: normal;
            text-align: justify;
            margin-top: 30px;
        }

        .hint .lower {
            margin-top: 45px;
        }

        .hint .lowerr {
            margin-top: 65px;
        }

        .hint:hover .hintt {
            visibility: visible;
        }

        .hint:hover .hintstay:hover {
            visibility: visible;
        }

        .tip::after {
            content: " ";
            position: absolute;
            bottom: 100%;
            left: 10%;
            margin-left: -10px;
            border-width: 10px;
            border-style: solid;
            border-color: transparent transparent black transparent;
        }

        .flip {
            left:-240px;
        }

        .flip::after {
            content: " ";
            position: absolute;
            bottom: 100%;
            left: 90%;
            margin-left: -10px;
            border-width: 10px;
            border-style: solid;
            border-color: transparent transparent black transparent;
        }

        th, td {
            padding: 10px;
            width: 7em;
        }

        th {
            background-color: white;
        }

        th:first-child, td:first-child {
            font-weight: bold;
            text-align: left;
            width: 3em;
            background-color: white;
        }

        tr:nth-child(odd) {
            background-color: #eFe;
        }

        tr:nth-child(even) {
            background-color: #cDc;
        }

        tr:first-child {

        }

        td {
            text-align: center;
        }

        table {
            border-spacing: 1px;
        }

        a, a:visited {
            color: #555;
        }

    </style>
</head>

<body>
<div id="main">
    <h1>Main Alignment-free Tools Comparisons</h1>
    <p>This table gives a summary of the main Alignment-free tools and their comparisons to each other.</p>

    <table>
        <! -- first row -->
        <tr>
            <th></th>
            <th class="hint"><span class="hintt tip">A sequence of elements, where each element consists of a value and a pointer to the next element in the sequence.</span>Category</th>
            <th class="hint"><span class="hintt tip lower">A sequence of elements, where each element consists of a value and a pointer to both the previous and the next element in the sequence.</span>Year</th>
            <th class="hint"><span class="hintt tip">A sequence of elements. There are no empty spaces between the elements.</span>Reference-free</th>
            <th class="hint"><span class="hintt tip">A sequence of sorted elements. There are no empty spaces between the elements.</span>Alignment-free</th>
            <th class="hint"><span class="hintt tip">An array that contains a bit for each possible value to indicate whether it is present (1) or not (0).</span>Short / Long reads</th>
            <th class="hint"><span class="hintt flip lower hintstay">A rooted binary tree of which each node stores a value and has 0, 1, or 2 children. If a node has children, each child is labeled either as the left or the right child. A node with 2 children has both a left and a right child.<br /><span style="font-weight:bold">Crucial:</span> For each node N, the values stored in the nodes in the subtree rooted at the left child of N are less than the value stored in N; the values stored in the nodes in the subtree rooted at the right child of N are all bigger than the value stored in N.<br />Based on the idea of the <a href="https://en.wikipedia.org/wiki/Binary_search_algorithm">binary search algorithm</a>.</span> Time Complexity</th>
            <th class="hint"><span class="hintt tip">A sequence of elements. There are no empty spaces between the elements.</span>Input</th>
            <th class="hint"><span class="hintt tip">A sequence of elements. There are no empty spaces between the elements.</span>Output</th>
            <th class="hint"><span class="hintt tip">A sequence of elements. There are no empty spaces between the elements.</span>Notes</th>
        </tr>
        <! -- Multi-SpaM -->
        <tr>
            <td class="hint"><span class="hintt tip">calculate P-blocks -> construct the quartet topology for each of the P-blocks -> amalgamate into a single tree spanning the entire taxa (Heuristic)</span>Multi-SpaM</td>
            <td>micros alignments (FSWM-based)</td>
            <td>2019</td>
            <td>/</td>
            <td>/</td>
            <td class="hint"><span class="hintt tip">The data structure is represented by an array D of size U, of which each element needs to be set to zero.</span>/</td>
            <td>n.a.</td>
            <td>FASTA file containing multiple genomes</td>
            <td>phylogeny tree (newick format)</td>
            <td>multiple sequence comparison</td>

        </tr>
        <! -- Prot-SpaM -->
        <tr>
            <td class="hint"><span class="hintt tip">calculate SWM -> filter SWM -> estimate distance</span>Prot-SpaM</td>
            <td>micros alignments (FSWM-based)</td>
            <td>2019</td>
            <td>/</td>
            <td>/</td>
            <td class="hint"><span class="hintt tip">The data structure is represented by an array D of size U, of which each element needs to be set to zero.</span>/</td>
            <td>n.a.</td>
            <td>whole proteome (FASTA)</td>
            <td>phylogeny tree</td>
            <td>protein sequence</td>
        </tr>
        <! -- Read-SpaM -->
        <tr>
            <td class="hint"><span class="hintt tip">calculate SWM -> filter SWM -> estimate distance (Jukes-cantor)</span>Prot-SpaM</td>
            <td>micros alignments (FSWM-based)</td>
            <td>2019</td>
            <td>Y</td>
            <td>Y</td>
            <td>Short</td>
            <td>n.a.</td>
            <td>unassembled reads (FASTA)</td>
            <td>phylogeny tree</td>
            <td>only on Linux</td>
        </tr>
        <! -- andi -->
        <tr>
            <td class="hint"><span class="hintt tip">andi estimates phylogenetic distances between genomic sequences based on ungapped local alignments that are flanked by maximal exact word matches. Such word matches can be efficiently found using suffix arrays.</span>andi</td>
            <td>micros alignments</td>
            <td>2015</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>O(length^1.05)</td>
            <td>genomic sequence</td>
            <td>pairwise distances</td>
            <td>/</td>
        </tr>
        <! -- Co-phylog -->
        <tr>
            <td class="hint"><span class="hintt tip">This method searches for so-called structures that are defined as pairs of k-mer matches between two DNA sequences that are one position apart in both sequences. The two k-mer matches are called the context, the position between them is called the object. Co-phylog then defines the distance between two sequences the fraction of such structures for which the two nucleotides in the object are different. The approach can be applied to unassembled sequencing reads.</span> Co-phylog</td>
            <td>micros alignments</td>
            <td>2010</td>
            <td>/</td>
            <td>Y</td>
            <td>/</td>
            <td>n.a.</td>
            <td>genomic sequence</td>
            <td>pairwise distances</td>
            <td>/</td>
        </tr>
        <! -- Slope-SpaM -->
        <tr>
            <td class="hint"><span class="hintt tip">This method calculates the number of k-mer or spaced-word matches (SpaM) for different values for the word length or number of match positions in the underlying pattern, respectively. The slope of an affine-linear function that depends on is calculated to estimate the Jukes-Cantor distance between the input sequences.</span>Slope-SpaM</td>
            <td>micros alignments (Number of Spaced-word matches)</td>
            <td>2020</td>
            <td>/</td>
            <td>Y</td>
            <td>/</td>
            <td>n.a.</td>
            <td>genomes (FASTA)</td>
            <td>pairwise Jukes-Cantor distances</td>
            <td>/</td>
        </tr>
        <! -- SANS -->
        <tr>
            <td class="hint"><span class="hintt tip">construct coloured de Bruijn graph for each genome -> accumulate split weights using trie data structures -> combine splits</span>SANS</td>
            <td>graphical representation</td>
            <td>2019</td>
            <td>Y</td>
            <td>/</td>
            <td>/</td>
            <td>O(mnlog(n))</td>
            <td>assembled genomes / reads</td>
            <td>weighted splits</td>
            <td>new version available (SANS serif: supports MACOS, WINDOWS)</td>
        </tr>
        <! -- D_{2}^*, D_{2}^S -->
        <tr>
            <td class="hint"><span class="hintt tip">construct coloured de Bruijn graph for each genome -> accumulate split weights using trie data structures -> combine splits</span>D_{2}^*, D_{2}^S</td>
            <td>Number of word matches</td>
            <td>2009</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>by Michael S. Waterman</td>
        </tr>
        <! -- MASH -->
        <tr>
            <td class="hint"><span class="hintt tip">This is an extremely fast method that uses the MinHash bottom sketch strategy for estimating the Jaccard index of the multi-sets of k-mers of two input sequences.</span>MASH</td>
            <td>Number of word matches</td>
            <td>2016</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>O(n + s log s log n) </td>
            <td>genomes</td>
            <td>pairwise distances</td>
            <td>very Fast</td>
        </tr>
        <! -- Skmer -->
        <tr>
            <td class="hint"><span class="hintt tip">Skmer calculates distances between species from unassembled sequencing reads. Similar to MASH, it uses the Jaccard index on the sets of k-mers from the input sequences. In contrast to MASH, the program is still accurate for low sequencing coverage.</span>SANS</td>
            <td>Number of word matches</td>
            <td>2019</td>
            <td>/</td>
            <td>Y</td>
            <td>/</td>
            <td>n.a.</td>
            <td>genomes</td>
            <td>pairwise distances</td>
            <td>similar to MASH</td>
        </tr>
        <! -- ACS -->
        <tr>
            <td class="hint"><span class="hintt tip">calculate averaged longest exact matches between two strings.</span>ACS</td>
            <td>Length of common substrings</td>
            <td>2005</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>O(m2 · l · log(l))</td>
            <td>genome / proteome</td>
            <td>pairwise distances</td>
            <td>Exact matching</td>
        </tr>
        <! -- kmacs -->
        <tr>
            <td class="hint"><span class="hintt tip">calculate averaged longest (k-mismatch tolerated) matches between two strings.</span>kmacs</td>
            <td>Length of common substrings</td>
            <td>2015</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>O(k*n*z) + O(|S1|+|S2|)</td>
            <td>genome / proteome (FASTA) max 10mb, 500 sequences</td>
            <td>pairwise distances</td>
            <td>Heuristic, based on ACS. Web interface available</td>
        </tr>
        <! -- FFPs -->
        <tr>
            <td class="hint"><span class="hintt tip">count each possible k-mer -> normalise -> generate FFP -> calculate Jensen-Shannon divergence.</span>FFPs</td>
            <td>Kmer frequency</td>
            <td>2011</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>n.a.</td>
            <td>genomes</td>
            <td>pairwise distances</td>
            <td>/</td>
        </tr>
        <! -- AAF -->
        <tr>
            <td class="hint"><span class="hintt tip">generate k-mer table -> estimate d -> tree estimation</span>AAF</td>
            <td>Kmer frequency</td>
            <td>2015</td>
            <td>/</td>
            <td>/</td>
            <td>/</td>
            <td>n.a.</td>
            <td>genomes</td>
            <td>pairwise distances</td>
            <td>/</td>
        </tr>

    </table>

    <p style="margin-top:50px">Adapted from 'Data Structures and Basic Operations' by <a href="http://www.erikjanvl.nl">Erik Jan van Leeuwen</a> and <a href="http://www-tcs.cs.uni-sb.de/">Raimund Seidel</a> in the lecture 'Algorithms and Data Structures' in Saarland University WS20.</p>

    <div style="height:500px;">&nbsp;</div>

</div>
</body>
</html>